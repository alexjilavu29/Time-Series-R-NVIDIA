##adecvata seriilor ce prezinta tendinta si  componenta sezoniera.
##Metoda implica trei ecuatii de recurenta, si prin urmare trei  constante de netezire, una pentru
##nivelul seriei, una pentru panta  dreptei de tendinta respectiv una pentru coeficientii sezonalitatii
## in functie de modelul de descompunere a seriei, aditiv sau multiplicativ, exista doua variante ale metodei
## HW multiplicativ si HW aditiv
aust <- window(austourists,start=2005)
fit1 <- hw(aust,seasonal="additive") # HW aditiv
fit2 <- hw(aust,seasonal="multiplicative") # HW multiplicativ
autoplot(aust) +
autolayer(fit1, series="HW additive forecasts", PI=FALSE) +
autolayer(fit2, series="HW multiplicative forecasts",
PI=FALSE) +
xlab("Year") +
ylab("Visitor nights (millions)") +
ggtitle("International visitors nights in Australia") +
guides(colour=guide_legend(title="Forecast"))
# Datele arata un model sezonier evident, cu vârfuri observate in trimestrul martie al fiecarui an,
# corespunzator verii australiene.
# Verificarea acuratetii modelelor
round(accuracy(fit1),2)
round(accuracy(fit2),2)
summary(fit1)
summary(fit2)
### Modelul ETS - Exponential smoothing with state space
# Fiecare model consta dintr-o ecuatie de masurare care descrie datele observate si unele ecuatii de
# stare care descriu modul in care componentele sau starile neobservate (nivel, tendinta, sezonier) se
# modifica in timp. Prin urmare, acestea sunt denumite space state models.
fit_ets <- ets(aust) # functia ets permite mai multi parametri, dar nu intra in scopul materiei de la licenta
summary(fit_ets) # acuratetea modelului
autoplot(fit_ets) # componentele modelului
# Valorile mici ale lui β si γ inseamna ca componente precum panta si sezonalitatea se schimba foarte
# putin in timp.
fit_ets %>% forecast::forecast(h=5) %>% # prognoza modelului
autoplot() +
ylab("Visitor nights (millions)")
# Intervalele de predictie inguste indica faptul ca seria este relativ
# usor de prevazut datorita tendintei puternice si sazonalitatii.
### Diagnosticul pe reziduuri ###
# Dupa ce aplicam un model trebuie sa verificam daca reziduurile se autocoreleaza
# Reziduurile sunt utile pentru a verifica daca modelul a capturat in mod adecvat informatia din serie
# Un model bun de prognoza va produce reziduuri cu urmatoarele proprietati
# 1. reziduurile nu sunt corelate. Daca reziduurile sunt corelate
# inseamna ca informatia ramasa in reziduuri trebuie folosita in prognoza
# 2. reziduurile au media 0. Daca reziduurile au media diferita de 0,
# rezultatele prognozate sunt biased
# 3. reziduurile au varianta constanta - testarea conditionata a heteroscedasticitatii
# 4. reziduurile sunt normal distribuite
res_hw_ad <- residuals(fit1)
autoplot(res_hw_ad) + xlab("Day") + ylab("") +
ggtitle("Residuals from HW additive")
# Histograma reziduurilor
gghistogram(res_hw_ad) + ggtitle("Histogram of residuals")
# Testarea prin Jarque-Berra a normalitatii reziduurilor
# H0: seria este normal distribuita
# H1: seria nu este normal distribuita
jarque.bera.test(res_hw_ad) # deoarece p-value > 0.05, seria este distribuita normal
# Functia de autocorelatie a reziduurilor
ggAcf(res_hw_ad) + ggtitle("ACF of residuals")
# Coeficientul de autocorelare este între -0.3 și 0.3
# Testul Box-Pierce
# H0: seria reziduurilor nu prezinta autocorelare
# H1: seria reziduurilor prezinta autocorelare
Box.test(res_hw_ad, lag=1)
Box.test(res_hw_ad, lag=2)
Box.test(res_hw_ad, lag=3)
Box.test(res_hw_ad, lag=4)
Box.test(res_hw_ad, lag=5)  #  p-value > 0.1 => seria reziduurilor nu prezinta autocorelare
Box.test(res_hw_ad, lag=10) #  p-value > 0.1 => seria reziduurilor nu prezinta autocorelare
Box.test(res_hw_ad, lag=1,type="Lj")
Box.test(res_hw_ad, lag=2, type="Lj")
Box.test(res_hw_ad, lag=3, type="Lj")
Box.test(res_hw_ad, lag=4, type="Lj")
Box.test(res_hw_ad, lag=5, type="Lj")
Box.test(res_hw_ad, lag=10, type="Lj") # p-value > 0.1 => seria reziduurilor nu prezinta autocorelare
library(fpp2)
library(vars)
library(tseries)
library(urca)
library(stats)
library(changepoint)
library(dplyr)
library(uroot)
library(TSA)
library(FinTS)
# ACF si PACF
# ACF reprezinta gradul de similitudine dintre o serie de timp
# si o versiune intarziata a acesteia pe intervale de timp succesive
# ACF masoara relatia dintre valoarea actuala a unei variabile si
# valorile trecute
#ACF la lagul k arată cât de corelat este un punct de date din serie cu un
#punct de date din trecut la un interval de timp k.
# Seria indicelui brusier google pe 200 de zile consecutive
autoplot(goog200) +
ggtitle('Google stock price for 200 consecutive days') +
theme_bw()
ggAcf(goog200) + theme_bw()
# Seria diferentei de ordinul 1
autoplot(diff(goog200)) +
ggtitle('Daily change in the Google stock price for 200 consecutive days') +
theme_bw()
ggAcf(diff(goog200))+ theme_bw()
# PACF masoara relatia dintre yt si yt-k dupa indepartarea efectelor lagurilor
# 1,2,3...,k-1
# Primul lag PACF este identic cu primul lag al ACF
# Fiecare autocorelatie partiala poate fi estimata ca ultimul coeficient intr-un model AR
# Functia PACF da corelatia partiala a unei serii de timp stationare cu propriile valori
# ramase, regresand valorile seriei de timp la toate intervalele mai scurte
# Diferența principală între ACF și PACF este modul în care sunt eliminate efectele lagurilor
# intermediare în calculul corelației. ACF măsoară corelația directă între două puncte de date la un
# anumit lag, în timp ce PACF măsoară corelația directă excluzând toate celelalte laguri intermediare.
# In practica, lagul 3 PACF nu ia in considerare corelatiile de la lagurile 1 si 2
# in calcularea acestuia si asa mai departe.
ggPacf(goog200) + theme_bw()
ggAcf(goog200) + theme_bw()
ggPacf(diff(goog200)) + theme_bw()
ggAcf(diff(goog200)) + theme_bw()
# Corelograma seriilor de timp este o diagrama a statisticilor de corelatie
# Functia ggtsdisplay ne ofera graficul seriei, ACF si PACF in acelasi plot
ggtsdisplay(goog200)
ggtsdisplay(diff(goog200))
# Modelele AutoRegresive (AR)
# Modelel autoregresive prognozeaza variabila de interes folosind o combinatie
# liniara intre a valorilor trecute ale variabile
# Termenul AR indica faptul ca exista o regresie a variabilei fata de ea insusi
# In esență, procesul AR spune că valoarea actuală a variabilei este o combinație
# liniară a valorilor sale anterioare, plus o componentă aleatoare
set.seed(123) # folosim functia set.seed pentru a reproduce aceleasi date
#atunci cand rulam scriptul pentru procesele simulate
# Set de date simulat
data <- tibble(
ar1 = arima.sim(model = list(ar = 0.8), n = 200),
ar2 = arima.sim(model=list(ar=c(.5,-0.3)),n=200, sd = 4) + 4,
ma1 = arima.sim(model = list(ma = 0.7), n = 200),
ma2 = arima.sim(list(ma = c(1.8,-0.56)),n = 200, sd=2),
arma10 = arima.sim(model = list(ar  = 0.4), n = 200),
arma01 = arima.sim(model = list(ma = 0.5), n = 200),
arma11 = arima.sim(model = list(ar = 0.4, ma = 0.5), n = 200),
arma21 = arima.sim(model = list(ar = c(0.6,-0.2), ma = c(0.4)), n = 200)
)
# Simularea unui proces AR(1)
ar1 <- as.ts(data$ar1)
ggtsdisplay(ar1) # un proces pur autoregresiv este considerat atunci cand
#lagurile ACF descresc lent, iar dupa primele n laguri ale PACF-ului
# identificam o scadere brusca
# Testarea modelului AR(1)
ar1_model <- Arima(ar1, order = c(1,0,0), include.mean = FALSE) # ARIMA(p,d,q)
summary(ar1_model)
coeftest(ar1_model) # testarea coeficientului ar1
# Testearea reziduurilor modelului AR1
residuals_ar1 <- residuals(ar1_model)
ggtsdisplay(residuals_ar1) # nu avem autocorelatie in reziduuri conform ACF
Box.test(residuals_ar1, lag=1,type="Lj") # nu avem autocorelare in reziduuri
jarque.bera.test(residuals_ar1)
ArchTest(residuals_ar1,lag=1)
# Pentru ca procesul AR(1) sa fie unul stationar, toate radacinile polinomului
# caracteristic trebuie sa fie situate in interiorul cercului unitate, altfel
# daca toate radacinile sunt situate in afara cercului unitate, avem de a face cu
# un proces inversabil (cand un proces este inversabil, inseamna ca se poate exprima
# valoarea variabilei yt (prezent) cu ajutorul socului curent et (eroarea) si
# valorile ei intarziate yt-1, yt-2,..)
autoplot(ar1_model)
# Simularea unui proces MA(1)
ma1 <- as.ts(data$ma1)
ggtsdisplay(ma1) # un proces pur MA (medie mobila) este considerat atunci cand
#lagurile PACF descresc lent sau sub forma unei sinusoidale (dinti de fierastrau),
# iar dupa primele n laguri ale ACF-ului identificam o scadere brusca
# Într-un proces MA, valoarea unei variabile într-un anumit moment de timp
# este determinată în principal de valorile erorilor aleatoare din trecut, și
# nu direct de valorile variabilei în sine.
# Deci, în esență, procesul MA spune că valoarea actuală a variabilei este o combinație
# liniară a erorilor aleatoare din trecut, plus o componentă aleatoare (eroarea curentă).
# Testarea modelului MA(1)
ma1_model <- Arima(ma1, order = c(0,0,1), include.mean = FALSE) # ARIMA(p,d,q)
summary(ma1_model)
coeftest(ma1_model) # testarea coeficientului ar1
# Testearea reziduurilor modelului MA1
residuals_ma1 <- residuals(ma1_model)
ggtsdisplay(residuals_ma1) # nu avem autocorelatie in reziduuri conform ACF
Box.test(residuals_ma1, lag=1,type="Lj") # nu avem autocorelare in reziduuri deoarece
# p > 0.1
jarque.bera.test(residuals_ma1)
ArchTest(residuals_ma1,lag=1)
# Testarea inversabilitatii
autoplot(ma1_model) # proces MA stationar deoarece punctul se afla in interiorul cercului
# Modelele ARMA
# ARMA(p,q) are o componenta autoregresiva si o componenta medie mobila
# componenta AR se justifica prin faptul ca variabilele economice au in evolutie
# un caracter inertial, iar componenta MA este efectul unor evenimente neasteptate
# Functia ACF poate face distinctia dintre un proces AR si MA pur. Impreuna cu PACF,
# este utila pentru a distinge un proces AR de un proces ARMA
# Simularea unui proces ARMA(1,0)
arma10 <- as.ts(data$arma10)
ggtsdisplay(arma10) # pentru a identifica valoarea AR ne uitam in PACF
#pentru a identifica valoarea MA ne uitam in ACF
# avem un proces de tipul ARMA(1,0) deoarece in PACF primul lag este seminificativ
# iar in ACF dupa primul lag avem o scadere brusca a betelor
# in acest caz se pot testa mai multe modele precum ARMA(1,0), ARMA(1,1), ARMA(1,2)
# iar modelul optim este cel cu toti paramterii semnificativi, dar si trecerea tuturor
# ipotezelor pe reziduuri
# Testarea modelului
ar1ma0_model <- Arima(arma10, order = c(1,0,0), include.mean = FALSE) # ARIMA(p,d,q)
ar1ma1_model <- Arima(arma10, order = c(1,0,1), include.mean = FALSE) # ARIMA(p,d,q)
ar1ma2_model <- Arima(arma10, order = c(1,0,2), include.mean = FALSE) # ARIMA(p,d,q)
summary(ar1ma0_model) # modelul ARMA(1,0) prezinta cel mai mic AIC
summary(ar1ma1_model)
summary(ar1ma2_model)
coeftest(ar1ma0_model) # testarea coeficientilor
coeftest(ar1ma1_model) # MA nu este semnificativ
coeftest(ar1ma2_model) # niciun coeficient nu este semnificativ
# In final, vom alege modelul ARMA(1,0) deoarece indeplineste testarea parametrilor
# coeficientul AR(1) fiind semnificativ
# Testearea reziduurilor modelului ARMA(1,0)
residuals_ar1ma0 <- residuals(ar1ma0_model)
ggtsdisplay(residuals_ar1ma0) # nu avem autocorelatie in reziduuri conform ACF
Box.test(residuals_ar1ma0, lag=1,type="Lj") # nu avem autocorelare in reziduuri deoarece
# p > 0.1
jarque.bera.test(residuals_ar1ma0)
ArchTest(residuals_ar1ma0,lag=1)
# Testarea inversabilitatii
autoplot(ar1ma0_model) # proces ARMA stationar deoarece punctul se afla in interiorul cercului
# Simularea unui proces ARMA(0,1)
arma01 <- as.ts(data$arma01)
ggtsdisplay(arma01)
# Identificarea coeficientilor ARMA(p,q) dupa criteriul informational AIC
arma32 <- as.ts(data$arma21)
ggtsdisplay(arma32) # din corelograma pare ca avem un proces ARMA(3,2) deoarece
# avem 3 lagrui semnificative in cadrul PACF pentru procesele AR, si 1 sau 2
# laguri seminificative in cadrul ACF pentru procele MA
arma_res <- rep(0,16)
arma_res[1] <- arima(arma32, order=c(3,0,2))$aic # fit arma(3,2) and save aic value
arma_res[2] <- arima(arma32, order=c(2,0,2))$aic
arma_res[3] <- arima(arma32, order=c(2,0,1))$aic
arma_res[4] <- arima(arma32, order=c(1,0,2))$aic
arma_res[5] <- arima(arma32, order=c(1,0,1))$aic
arma_res[6] <- arima(arma32, order=c(3,0,0))$aic
arma_res[7] <- arima(arma32, order=c(2,0,0))$aic
arma_res[8] <- arima(arma32, order=c(0,0,2))$aic
arma_res[9]  <- arima(arma32, order=c(3,0,2), include.mean=FALSE)$aic
arma_res[10] <- arima(arma32, order=c(2,0,2), include.mean=FALSE)$aic
arma_res[11] <- arima(arma32, order=c(2,0,1), include.mean=FALSE)$aic
arma_res[12] <- arima(arma32, order=c(1,0,2), include.mean=FALSE)$aic
arma_res[13] <- arima(arma32, order=c(1,0,1), include.mean=FALSE)$aic
arma_res[14] <- arima(arma32, order=c(3,0,0), include.mean=FALSE)$aic
arma_res[15] <- arima(arma32, order=c(2,0,0), include.mean=FALSE)$aic
arma_res[16] <- arima(arma32, order=c(0,0,2), include.mean=FALSE)$aic
# Aflarea modelului cu cel mai mic AIC
which(arma_res == min(arma_res)) # al 14 model are cel mai mic AIC si este identificat
# printr-un proces ARMA(3,0), urmeaza sa testam coeficientii si ipotezele pe reziduuri
ar3ma0 <- arima(arma32, order=c(3,0,0), include.mean=FALSE)
coeftest(ar3ma0) # toti coeficientii sunt seminificati
residuals_ar3ma0 <- residuals(ar3ma0)
ggtsdisplay(residuals_ar3ma0) # nu avem autocorelatie in reziduuri conform ACF
Box.test(residuals_ar3ma0, lag=11,type="Lj") # nu avem autocorelare in reziduuri deoarece
# p > 0.1
jarque.bera.test(residuals_ar1ma0)
ArchTest(residuals_ar1ma0,lag=1)
# Astfel am identificat modelul optim ca fiind ARMA(3,0)
# Procesele ARIMA(p,d,q) se comporta identic cu cele ARMA, singura diferenta este
# data de d, care reprezinta numarul de diferentieri ale seriei (cel mai comun 1)
# ARIMA - autoregresive integrated moving average
# Atunci cand diferentiem o data seria noastra pentru a deveni stationara,
# procesul ARIMA va fi din start ARIMA(p,1,q) trebuind doar sa identificam lagurile
# p si q
# Exemplu aplicatie ARIMA pentru date fara sezonalitate
autoplot(uschange[,"Consumption"]) +
xlab("Year") + ylab("Quarterly percentage change") +
ggtitle("Quarterly percentage change in US consumption expenditure") +
theme_bw() # seria modificarii procentuale trimestriala a cheltuielilor de consum din SUA
# Testare sezonalitate
ggsubseriesplot(uschange[,"Consumption"]) + theme_bw() +
ggtitle('Sesonality patterns') +
ylab('Quarterly percentage change')
# deoarece mediile pe sezoane sunt similare nu avem sezonalitate in date
# daca exista diferenta mare intre pozitia liniei albastre orizontala
# pe trimestre, atunci aveam sezonalitate in date
# ADF
rw_none <- ur.df(uschange[,"Consumption"], type='none', selectlags = c("AIC"))
summary(rw_none) # prob z.lag.1 si z.diff.lag < 0.1 deci seria este stationara
rw_t <- ur.df(uschange[,"Consumption"], type='drift', selectlags = c("AIC"))
summary(rw_t) # prob < 0.1 deci seria este stationara
rw_ct <- ur.df(uschange[,"Consumption"], type='trend', selectlags = c("AIC"))
summary(rw_ct) # prob < 0.1 deci seria este stationara
# Conform testului ADF seria este stationara
# KPSS
uschange[,"Consumption"] %>% ur.kpss() %>% summary() # valoarea testului 0.28 < toate valorile critice
# seria este stationara conform ipotezele KPSS
# Philips-Perron
PP.test(uschange[,"Consumption"]) # p < 0.01 serie stationara
# Conform testelor de stationaritate, nu este nevoie sa diferentiem seria deoarece
# este stationara in medie si dispersie
ndiffs(uschange[,"Consumption"])
# Corelograma seriei
ggtsdisplay(uschange[,"Consumption"]) # vom testa o combinatie de modele
# din corelograma modelul optim pare a fi ARIMA(3,0,3)
# vom folosi functia auto.arima pentru identifica automat modelul cu cel mai mic AIC
# dezavantajul functiei auto.arima este ca nu testeaza semnificatia coeficientilor modelului
arima_auto <- auto.arima(uschange[,"Consumption"], seasonal=FALSE)
summary(arima_auto) # AIC = 341
arima303 <- Arima(uschange[,"Consumption"], order=c(3,0,3))
summary(arima303) # AIC = 344
# Modelul identificat automat are un AIC mai mic
coeftest(arima_auto) # MA2 nesemnificativ
coeftest(arima303) # multi coeficienti nesemnificativi
# In continuare vom testa combinatii de modele pentru a identifica modelul cu
# toti coeficientii semnificativi
arima203 <- Arima(uschange[,"Consumption"], order=c(2,0,3))
summary(arima203)
coeftest(arima203) # nu avem toti coeficientii semnificativi
arima202 <- Arima(uschange[,"Consumption"], order=c(2,0,2))
coeftest(arima202) # toti coeficientii sunt semnificativi
arima101 <- Arima(uschange[,"Consumption"], order=c(1,0,1))
coeftest(arima101) # toti coeficientii sunt semnificativi
# Comparam cele doua modele pentru a-l alege pe cel cu criteriile informationate
# si erorile minimizate
summary(arima202) # AIC = 342.28 RMSE = 0.584 #MAPE= 170.7 #MASE = 0.777
summary(arima101) # AIC = 343.8 RMSE = 0.593 #MAPE= 168.03 #MASE = 0.781
# Testarea inversabilitatii
autoplot(arima202) # proces stationar deoarece punctele se afla in cercuri
# Modelul optim identificat este ARIMA(2,0,2)
# Puteti testa toate combinatiile de modele in identificarea modelului optim care nu au
# fost testate in cadrul seminarului
# Diagnosticul pe reziduuri ale modelului
residuals_arima202 <- residuals(arima202)
ggtsdisplay(residuals_arima202) # nu avem autocorelatie in reziduuri conform ACF
Box.test(residuals_arima202, lag=1,type="Lj") # nu avem autocorelare in reziduuri deoarece
# p > 0.1
Box.test(residuals_arima202, lag=8,type="Lj")
Box.test(residuals_arima202, lag=22,type="Lj")
ArchTest(residuals_arima202, lags = 3)
jarque.bera.test(residuals_arima202)
# Modelul este bun pentru prognoza
arima202 %>% forecast(h=10) %>% autoplot(include=80) +
xlab("Year") + ylab("Quarterly percentage change") + theme_bw()
# Identificarea modelului optim ARIMA(p,d,q)
ggtsdisplay(diff(elec_adj)) # modelul optim conform corelogramei ar putea fi
arima202 %>% forecast(h=10) %>% autoplot(include=80) +
xlab("Year") + ylab("Quarterly percentage change") + theme_bw()
# Vom aplica in continuare si un model ETS pentru a compara prognoza pentru cele doua modele
fit_ets <- ets(uschange[,"Consumption"])
summary(fit_ets) # AIC = 804, RMSE = 0.61, MAPE = 157.97, MASE=0.707
# Prognoza
fit_ets %>% forecast::forecast(h=10) %>% # prognoza modelului
autoplot() +
ylab("Quarterly percentage change")
# Compararea modelelor cu ajutorul testului Diebold Mariano
dm.test(residuals(fit_ets),residuals(arima202))# deoarece p < 0.1 respingem H0
autoplot(elecequip) +
ggtitle("Seria lunara a vanzarii de echipamente electrice din EU") +
ylab('Milioane') +
theme_bw() # seria echipamentelor electrice date lunare la nivelul UE
# Testarea sezonalitatii
ggsubseriesplot(elecequip) + theme_bw() +
ggtitle('Sesonality patterns') +
ylab('Monthly percentage change')
# Vom descompune seria printr-o tehnica mai puternica decat mediile mobile
# folosita in majoritatea cazurilor - STL
elec_adj <- elecequip %>% stl(s.window='periodic') %>% seasadj()
autoplot(elec_adj) +
ggtitle("Seria lunara ajustata a vanzarii de echipamente electrice din EU") +
ylab('Milioane') +
theme_bw()
# Retestarea sezonalitatii
ggsubseriesplot(elec_adj) + theme_bw() +
ggtitle('Sesonality patterns') +
ylab('Monthly percentage change') # sezonalitatea este eliminata
# ADF
rw_none <- ur.df(elec_adj, type='none', selectlags = c("AIC"))
summary(rw_none) # nestationara, val test < val critice
rw_t <- ur.df(elec_adj, type='drift', selectlags = c("AIC"))
summary(rw_t) # nestationara
rw_ct <- ur.df(elec_adj, type='trend', selectlags = c("AIC"))
summary(rw_ct) # nestationara
# KPSS
elec_adj %>% ur.kpss() %>% summary() # valoarea testului 0.7 <  0.73
# Philips-Perron
PP.test(elec_adj) # p > 0.57 serie nestationara
# Seria este nestationara analizand toate testele si vom avea nevoie sa o diferentiem
ndiffs(elec_adj)
# Corelograma seriei
ggtsdisplay(elec_adj) # conform ACF seria noastra este nestationara si vom produce
ggtsdisplay(diff(elec_adj)) # seria devine stationara dupa prima diferenta conform corelogramei
# KPSS
diff(elec_adj) %>% ur.kpss() %>% summary() # valoarea testului 0.1 <  valorile critice
# Philips-Perron
PP.test(diff(elec_adj)) # p < 0.01 serie stationara
# Identificarea modelului optim ARIMA(p,d,q)
ggtsdisplay(diff(elec_adj)) # modelul optim conform corelogramei ar putea fi
# Loading the libraries
library(gt)
library(fpp2)
library(vars)
library(tseries)
library(urca)
library(stats)
library(changepoint)
library(dplyr)
library(uroot)
library(TSA)
library(readxl)
library(gt)
library(FinTS)
# SARIMA
# Atunci cand seria de timp prezinta sezonalitate puternica, o alternativa mai
# buna a modelului ARIMA, este modelul SARIMA (seasonal autoregresive integrated moving average)
# deoarece tine cont si de sezonalitatea seriei
# Modelele de tip SARIMA(p,d,q)(P,D,Q)m se formeaza incluzand componenta sezoniera
# m reprezinta numarul de observatii per an
# Componenta sezoniera pentru AR si MA se identifica tot pe baza corelogramei
# De exemplu un model ARIMA(0,0,0)(0,0,1)12 va arata doar un lag (bat) semnificativ
# la lagul 12 pe ACF si scadere lenta pe PACF la lagurile sezoniere
# Modelarea SARIMA este identica cu cea de la ARIMA pentru componentele AR si MA,
# adaugandu-se la acestea si componentele SAR si SMA
# Exemplu pe date trimiestriale retail index
# Graficul seriei
autoplot(euretail) + ylab("Retail index") + xlab("Year") +
ggtitle('Quarterly european retail index') + theme_bw()+
theme(plot.title = element_text(hjust = 0.5))
# Graficul de sezonalitate
ggsubseriesplot(euretail) +
ylab("Retail index") +
ggtitle("Seasonal subseries plot: quarterly european retail index") +
theme_bw()+
theme(plot.title = element_text(hjust = 0.5))
# Corelograma seriei
ggtsdisplay(euretail)
# Testarea radacinii unitare
#none
rw_none <- ur.df(euretail, type='none', selectlags = c("AIC"))
summary(rw_none) # nonstationary ts
#drift
rw_t <- ur.df(euretail, type='drift', selectlags = c("AIC"))
summary(rw_t) # nonstationary ts
#trend
rw_ct <- ur.df(euretail, type='trend', selectlags = c("AIC"))
summary(rw_ct) # nonstationary ts
# KPSS
euretail %>% ur.kpss() %>% summary() # t > critical values => nonstationary ts
# Philips-Perron
PP.test(euretail) # p > 0.1 => nonstationary ts
# Testarea radacinii unitare sezoniere
# Hegy
hegy.test(euretail) # p > 0.1 for t_1 => seasonal unit root
# Canova Hansens test
# H0: stable seasonal pattern
# H1: unstable seasonal pattern
ch.test(euretail) # p < 0.1 stable seasonal pattern
# Seria prezinta nestationaritate pe componenta sezoniera, dar si in nivel
# Vom aplica diferenta sezoniera in prima faza
euretail %>% diff(lag=4) %>% ggtsdisplay() # seria ramane nestationara si este nevoie
# si de diferenta de ordin 1
# la proiect, este nevoie sa testati din nou cu cu ADF, KPSS, PP
# Seria diferentiata sezonier si de ordin 1
euretail %>% diff(lag=4) %>% diff() %>% ggtsdisplay() # seria pare sa devina stationara
# si vom testa din nou cu ADF, KPSS, PP
euretail_diff <- euretail %>% diff(lag=4) %>% diff()
#none
rw_none <- ur.df(euretail_diff, type='none', selectlags = c("AIC"))
summary(rw_none) # stationary ts
#drift
rw_t <- ur.df(euretail_diff, type='drift', selectlags = c("AIC"))
summary(rw_t) # stationary ts
#trend
rw_ct <- ur.df(euretail_diff, type='trend', selectlags = c("AIC"))
summary(rw_ct) # stationary ts
# KPSS
euretail_diff %>% ur.kpss() %>% summary() # t < critical values => stationary ts
# Philips-Perron
PP.test(euretail_diff) # p < 0.01 => stationary ts
ggtsdisplay(euretail_diff)
# Pe baza corelogramei putem identifica lagurile maximale pe toate componentele
# Lagurile AR si MA se identifica similar cu ARIMA - AR(1), MA(1)
# Componenta SAR se identifica pe PACF pentru lagurile sezoniere SAR(1)
# Componenta SMA se identifica pe ACF pentru lagurile sezoniere SMA(1)
# (p,d,q)            (P,D,Q)
fit1 <- Arima(euretail,order=c(1,1,1), seasonal=c(1,1,1))
coeftest(fit1) #SAR nesemnificativ
fit2 <- Arima(euretail,order=c(1,1,1), seasonal=c(0,1,1))
coeftest(fit2) # SMA nesemnificativ
fit3 <- Arima(euretail,order=c(0,1,1), seasonal=c(1,1,1))
coeftest(fit3) # SAR neseminificativ
fit4 <- Arima(euretail,order=c(0,1,1), seasonal=c(0,1,1))
coeftest(fit4) # model potential
fit5 <- Arima(euretail,order=c(1,1,0), seasonal=c(0,1,1))
coeftest(fit5) # model potential
fit6 <- Arima(euretail,order=c(1,1,0), seasonal=c(1,1,0))
coeftest(fit6) # model potential
auto.arima(euretail) # identifica MA(3) - care este nesemnificativ inca din corelograma
summary(fit4) # AIC = 75.28   BIC = 81.51  ARIMA(0,1,1)x(0,1,1)[4]
summary(fit5) # AIC = 71.41   BIC = 77.64  ARIMA(1,1,0)x(0,1,1)[4]
summary(fit6) # AIC = 76.57   BIC = 82.8   ARIMA(1,1,0)x(1,1,0)[4]
# Modelul cu cele mai mici criterii informationale este SARIMA(1,1,0)(0,1,1)4
# si vom testa reziduurile
# Testarea reziduurilor
checkresiduals(fit5)
#Autocorelare
Box.test(residuals(fit5),lag = 1, type = 'Lj')
Box.test(residuals(fit5),lag = 2, type = 'Lj')
Box.test(residuals(fit5),lag = 3, type = 'Lj')
Box.test(residuals(fit5),lag = 4, type = 'Lj')
Box.test(residuals(fit5),lag = 5, type = 'Lj') # reziduurile nu prezinta autocorelare
Box.test(residuals(fit5),lag = 8, type = 'Lj')
Box.test(residuals(fit5),lag = 12, type = 'Lj')
# Normalitate
jarque.bera.test(residuals(fit5)) # reziduuri normal distribuite
# Heteroschedasticitate
# Heteroschedasticitate
ArchTest(residuals(fit5), lags = 1)
ArchTest(residuals(fit5), lags = 2)
ArchTest(residuals(fit5), lags = 3)
ArchTest(residuals(fit5), lags = 4)
ArchTest(residuals(fit5), lags = 8)
ArchTest(residuals(fit5), lags = 12) # reziduurile nu prezinta heterosc
